#pragma once

#include "../sdk.hpp"
#include <iostream>
#include "../../helpers/utils.hpp"
	/*
	typedef int HKeySymbol;
	#define INVALID_KEY_SYMBOL (-1)

	class IBaseFileSystem;
	class KeyValues;

	//-----------------------------------------------------------------------------
	// Purpose: Interface to shared data repository for KeyValues (included in vgui_controls.lib)
	//			allows for central data storage point of KeyValues symbol table
	//-----------------------------------------------------------------------------
	class IKeyValuesSystem
	{
	public:
	// registers the size of the KeyValues in the specified instance
	// so it can build a properly sized memory pool for the KeyValues objects
	// the sizes will usually never differ but this is for versioning safety
	virtual void RegisterSizeofKeyValues(int size) = 0;

	// allocates/frees a KeyValues object from the shared mempool
	virtual void *AllocKeyValuesMemory(int size) = 0;
	virtual void FreeKeyValuesMemory(void *pMem) = 0;

	// symbol table access (used for key names)
	virtual HKeySymbol GetSymbolForString(const char *name, bool bCreate = true) = 0;
	virtual const char *GetStringForSymbol(HKeySymbol symbol) = 0;

	// for debugging, adds KeyValues record into global list so we can track memory leaks
	virtual void AddKeyValuesToMemoryLeakList(void *pMem, HKeySymbol name) = 0;
	virtual void RemoveKeyValuesFromMemoryLeakList(void *pMem) = 0;

	// maintain a cache of KeyValues we load from disk. This saves us quite a lot of time on app startup.
	virtual void AddFileKeyValuesToCache(const KeyValues* _kv, const char *resourceName, const char *pathID) = 0;
	virtual bool LoadFileKeyValuesFromCache(KeyValues* _outKv, const char *resourceName, const char *pathID, IBaseFileSystem *filesystem) const = 0;
	virtual void InvalidateCache() = 0;
	virtual void InvalidateCacheForFile(const char *resourceName, const char *pathID) = 0;
	};


	#define KEYVALUESSYSTEM_INTERFACE_VERSION "KeyValuesSystem002"
	*/
	class KeyValues
	{
	private:
		static PVOID KeyValuesSystem;
	public:
		static void SetUseGrowableStringTable( bool bUseGrowableTable );
		void InitKetValues(KeyValues* pKeyValues, const char* name);
		KeyValues( const char *setName )
		{
			Init();
			SetName( setName );
		}
		/**/
		PVOID operator new(size_t iAllocSize)
		{
			static PVOID KeyValuesSystem = nullptr;
			if (!KeyValuesSystem)
			{
				typedef PVOID(__cdecl* oKeyValuesSystem)();
				oKeyValuesSystem KeyValuesSystem1 = (oKeyValuesSystem)GetProcAddress(GetModuleHandleA("vstdlib.dll"), "KeyValuesSystem");

				KeyValuesSystem = KeyValuesSystem1();
			}

			typedef PVOID(__thiscall* oAllocKeyValuesMemory)(PVOID, size_t);
			return CallVFunction<oAllocKeyValuesMemory>(KeyValuesSystem, 1)(KeyValuesSystem, iAllocSize);
		}

		void operator delete(PVOID pMem)
		{
			static PVOID KeyValuesSystem = nullptr;
			if (!KeyValuesSystem)
			{
				typedef PVOID(__cdecl* oKeyValuesSystem)();
				oKeyValuesSystem KeyValuesSystem1 = (oKeyValuesSystem)GetProcAddress(GetModuleHandleA("vstdlib.dll"), "KeyValuesSystem");

				KeyValuesSystem = KeyValuesSystem1();
			}

			typedef void(__thiscall* oFreeKeyValuesMemory)(PVOID, PVOID);
			CallVFunction<oFreeKeyValuesMemory>(KeyValuesSystem, 2)(KeyValuesSystem, pMem);
		}
		
		class AutoDelete
		{
		public:
			explicit inline AutoDelete( KeyValues *pKeyValues ) : m_pKeyValues( pKeyValues ) {}
			explicit inline AutoDelete( const char *pchKVName ) : m_pKeyValues( new KeyValues( pchKVName ) ) {}
			inline ~AutoDelete( void ) { if ( m_pKeyValues ) m_pKeyValues->deleteThis(); }
			inline void Assign( KeyValues *pKeyValues ) { m_pKeyValues = pKeyValues; }
			KeyValues *operator->() { return m_pKeyValues; }
			operator KeyValues *( ) { return m_pKeyValues; }
		private:
			AutoDelete( AutoDelete const &x ); // forbid
			AutoDelete & operator= ( AutoDelete const &x ); // forbid
			KeyValues *m_pKeyValues;
		};
	public:
		const char *GetName() const;
		void SetName( const char *setName )
		{
			m_iKeyName = 2;
		}

		int GetNameSymbol() const { return m_iKeyName; }

		void UsesEscapeSequences( bool state ); // default false
		void UsesConditionals( bool state ); // default true

		KeyValues *FindKey(const char *keyName, bool bCreate = false);
		KeyValues *FindKey( int keySymbol ) const;
		KeyValues *CreateNewKey();		// creates a new key, with an autogenerated name.  name is guaranteed to be an integer, of value 1 higher than the highest other integer key name
		void AddSubKey( KeyValues *pSubkey );	// Adds a subkey. Make sure the subkey isn't a child of some other keyvalues
		void RemoveSubKey( KeyValues *subKey );	// removes a subkey from the list, DOES NOT DELETE IT

		KeyValues *GetFirstSubKey() { return m_pSub; }	// returns the first subkey in the list
		KeyValues *GetNextKey() { return m_pPeer; }		// returns the next subkey
		void SetNextKey( KeyValues * pDat );
		KeyValues *FindLastSubKey();	// returns the LAST subkey in the list.  This requires a linked list iteration to find the key.  Returns NULL if we don't have any children

		KeyValues* GetFirstTrueSubKey();
		KeyValues* GetNextTrueSubKey();

		KeyValues* GetFirstValue();	// When you get a value back, you can use GetX and pass in NULL to get the value.
		KeyValues* GetNextValue();

		// Data access
		int   GetInt(const char *keyName = NULL, int defaultValue = 0);
		float GetFloat( const char *keyName = NULL , float defaultValue = 0.0f );
		const char *GetString(const char *keyName = NULL, const char *defaultValue = "");
		const wchar_t *GetWString( const char *keyName = NULL , const wchar_t *defaultValue = L"" );
		void *GetPtr( const char *keyName = NULL , void *defaultValue = (void*)0 );
		bool GetBool( const char *keyName = NULL , bool defaultValue = false );
		bool  IsEmpty( const char *keyName = NULL );

		// Data access
		int   GetInt( int keySymbol , int defaultValue = 0 );
		float GetFloat( int keySymbol , float defaultValue = 0.0f );
		const char *GetString( int keySymbol , const char *defaultValue = "" );
		const wchar_t *GetWString( int keySymbol , const wchar_t *defaultValue = L"" );
		void *GetPtr( int keySymbol , void *defaultValue = (void*)0 );
		bool  IsEmpty( int keySymbol );

		// Key writing
		void SetWString( const char *keyName , const wchar_t *value );
		void SetString(const char *value);
		void SetString(const char *keyName, const char *value);
		//void KeyValues::SetInt(int value) {
		//	*reinterpret_cast<int *>(reinterpret_cast<uintptr_t>(this) + 12) = value;
		//	*reinterpret_cast<char *>(reinterpret_cast<uintptr_t>(this) + 16) = 2; /* TYPE_INT = 2 */
		//}
		void SetInt(const char *keyName, int value) {
			auto key_int = FindKey(keyName,true);
			//std::cout << std::hex << key_int << std::dec << std::endl;
			if (key_int)
			{
				key_int->m_iDataType = 2;
				key_int->m_iValue = value;
				//*reinterpret_cast<int*>(reinterpret_cast<uintptr_t>(key_int) + 0xC) = value;
				//*reinterpret_cast<char*>(reinterpret_cast<uintptr_t>(key_int) + 0x10) = 2;
			}
		}
		void SetUint64(const char *keyName, uint64 value);
		void SetUint64(const char* keyName, int value, int value2);
		void SetFloat( const char *keyName , float value );
		void SetPtr( const char *keyName , void *value );
		void SetBool( const char *keyName , bool value ) { SetInt( keyName , value ? 1 : 0 ); }

		KeyValues& operator=( KeyValues& src );

		// Adds a chain... if we don't find stuff in this keyvalue, we'll look
		// in the one we're chained to.
		void ChainKeyValue( KeyValues* pChain );

		// Allocate & create a new copy of the keys
		KeyValues *MakeCopy( void ) const;

		// Make a new copy of all subkeys, add them all to the passed-in keyvalues
		void CopySubkeys( KeyValues *pParent ) const;

		// Clear out all subkeys, and the current value
		void Clear( void );

		// Data type
		enum types_t
		{
			TYPE_NONE = 0 ,
			TYPE_STRING ,
			TYPE_INT ,
			TYPE_FLOAT ,
			TYPE_PTR ,
			TYPE_WSTRING ,
			TYPE_COLOR ,
			TYPE_UINT64 ,
			TYPE_NUMTYPES ,
		};
		types_t GetDataType( const char *keyName = NULL );

		// Virtual deletion function - ensures that KeyValues object is deleted from correct heap
		void deleteThis();

		void SetStringValue( char const *strValue );

		// unpack a key values list into a structure
		void UnpackIntoStructure( struct KeyValuesUnpackStructure const *pUnpackTable , void *pDest , size_t DestSizeInBytes );

		// Process conditional keys for widescreen support.
		bool ProcessResolutionKeys( const char *pResString );

		// Dump keyvalues recursively into a dump context
		bool Dump( class IKeyValuesDumpContext *pDump , int nIndentLevel = 0 );

		// Merge in another KeyValues, keeping "our" settings
		void RecursiveMergeKeyValues( KeyValues *baseKV );

	public:
		KeyValues( KeyValues& );	// prevent copy constructor being used

									// prevent delete being called except through deleteThis()
		~KeyValues();

		KeyValues* CreateKey( const char *keyName );

		KeyValues* CreateKeyUsingKnownLastChild( const char *keyName , KeyValues *pLastChild );
		void AddSubkeyUsingKnownLastChild( KeyValues *pSubKey , KeyValues *pLastChild );

		void RecursiveCopyKeyValues( KeyValues& src );
		void RemoveEverything();

		void Init()
		{
			m_iKeyName = -1;
			m_iDataType = TYPE_NONE;

			m_pSub = NULL;
			m_pPeer = NULL;
			m_pChain = NULL;

			m_sValue = NULL;
			m_wsValue = NULL;
			m_pValue = NULL;

			m_bHasEscapeSequences = false;

			// for future proof
			memset( unused , 0 , sizeof( unused ) );
		}

		void FreeAllocatedValue();
		void AllocateValueBlock( int size );

		int m_iKeyName;	// keyname is a symbol defined in KeyValuesSystem

						// These are needed out of the union because the API returns string pointers
		char *m_sValue;
		wchar_t *m_wsValue;

		// we don't delete these
		union
		{
			int m_iValue;
			float m_flValue;
			void *m_pValue;
			unsigned char m_Color[4];
		};

		char	   m_iDataType;
		char	   m_bHasEscapeSequences; // true, if while parsing this KeyValue, Escape Sequences are used (default false)
		char	   m_bEvaluateConditionals; // true, if while parsing this KeyValue, conditionals blocks are evaluated (default true)
		char	   unused[1];

		KeyValues *m_pPeer;	// pointer to next key in list
		KeyValues *m_pSub;	// pointer to Start of a new sub key list
		KeyValues *m_pChain;// Search here if it's not in our list

	private:
		// Statics to implement the optional growable string table
		// Function pointers that will determine which mode we are in
		static int( *s_pfGetSymbolForString )( const char *name , bool bCreate );
		static const char *( *s_pfGetStringForSymbol )( int symbol );

	public:
		// Functions that invoke the default behavior
		static int GetSymbolForStringClassic( const char *name , bool bCreate = true );
		static const char *GetStringForSymbolClassic( int symbol );

		// Functions that use the growable string table
		static int GetSymbolForStringGrowable( const char *name , bool bCreate = true );
		static const char *GetStringForSymbolGrowable( int symbol );

		// Functions to get external access to whichever of the above functions we're going to call.
		static int CallGetSymbolForString( const char *name , bool bCreate = true ) { return s_pfGetSymbolForString( name , bCreate ); }
		static const char *CallGetStringForSymbol( int symbol ) { return s_pfGetStringForSymbol( symbol ); }

		bool LoadFromBuffer( KeyValues *pThis , const char *pszFirst , const char *pszSecond , PVOID pSomething = 0 , PVOID pAnother = 0 , PVOID pLast = 0 );
	};